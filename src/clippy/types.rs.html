<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `/Users/tim/.multirust/toolchains/nightly/cargo/registry/src/github.com-88ac128001ac3a9a/clippy-0.0.37/src/types.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>types.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
</pre><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>rustc</span>::<span class='ident'>lint</span>::<span class='op'>*</span>;
<span class='kw'>use</span> <span class='ident'>rustc_front</span>::<span class='ident'>hir</span>::<span class='op'>*</span>;
<span class='kw'>use</span> <span class='ident'>reexport</span>::<span class='op'>*</span>;
<span class='kw'>use</span> <span class='ident'>rustc_front</span>::<span class='ident'>util</span>::{<span class='ident'>is_comparison_binop</span>, <span class='ident'>binop_to_string</span>};
<span class='kw'>use</span> <span class='ident'>syntax</span>::<span class='ident'>codemap</span>::<span class='ident'>Span</span>;
<span class='kw'>use</span> <span class='ident'>rustc_front</span>::<span class='ident'>intravisit</span>::{<span class='ident'>FnKind</span>, <span class='ident'>Visitor</span>, <span class='ident'>walk_ty</span>};
<span class='kw'>use</span> <span class='ident'>rustc</span>::<span class='ident'>middle</span>::<span class='ident'>ty</span>;
<span class='kw'>use</span> <span class='ident'>syntax</span>::<span class='ident'>ast</span>::<span class='ident'>IntTy</span>::<span class='op'>*</span>;
<span class='kw'>use</span> <span class='ident'>syntax</span>::<span class='ident'>ast</span>::<span class='ident'>UintTy</span>::<span class='op'>*</span>;
<span class='kw'>use</span> <span class='ident'>syntax</span>::<span class='ident'>ast</span>::<span class='ident'>FloatTy</span>::<span class='op'>*</span>;

<span class='kw'>use</span> <span class='ident'>utils</span>::<span class='op'>*</span>;

<span class='doccomment'>/// Handles all the linting of funky types</span>
<span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_copy_implementations</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>TypePass</span>;

<span class='doccomment'>/// **What it does:** This lint checks for use of `Box&lt;Vec&lt;_&gt;&gt;` anywhere in the code. It is `Warn` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you `Box` it, you just add another level of indirection without any benefit whatsoever.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `struct X { values: Box&lt;Vec&lt;Foo&gt;&gt; }`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>BOX_VEC</span>, <span class='ident'>Warn</span>,
              <span class='string'>&quot;usage of `Box&lt;Vec&lt;T&gt;&gt;`, vector elements are already on the heap&quot;</span>);

<span class='doccomment'>/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`). It is `Warn` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** Gankro says:</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// &gt;The TL;DR of `LinkedList` is that it&#39;s built on a massive amount of pointers and indirection. It wastes memory, it has terrible cache locality, and is all-around slow. `RingBuf`, while &quot;only&quot; amortized for push/pop, should be faster in the general case for almost every possible workload, and isn&#39;t even amortized at all if you can predict the capacity you need.</span>
<span class='doccomment'>/// &gt;</span>
<span class='doccomment'>/// &gt; `LinkedList`s are only really good if you&#39;re doing a lot of merging or splitting of lists. This is because they can just mangle some pointers instead of actually copying the data. Even if you&#39;re doing a lot of insertion in the middle of the list, `RingBuf` can still be better because of how expensive it is to seek to the middle of a `LinkedList`.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** False positives – the instances where using a `LinkedList` makes sense are few and far between, but they can still happen.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `let x = LinkedList::new();`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>LINKEDLIST</span>, <span class='ident'>Warn</span>,
              <span class='string'>&quot;usage of LinkedList, usually a vector is faster, or a more specialized data \
               structure like a VecDeque&quot;</span>);

<span class='kw'>impl</span> <span class='ident'>LintPass</span> <span class='kw'>for</span> <span class='ident'>TypePass</span> {
    <span class='kw'>fn</span> <span class='ident'>get_lints</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LintArray</span> {
        <span class='macro'>lint_array</span><span class='macro'>!</span>(<span class='ident'>BOX_VEC</span>, <span class='ident'>LINKEDLIST</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>LateLintPass</span> <span class='kw'>for</span> <span class='ident'>TypePass</span> {
    <span class='kw'>fn</span> <span class='ident'>check_ty</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>ast_ty</span>: <span class='kw-2'>&amp;</span><span class='ident'>Ty</span>) {
        <span class='kw'>if</span> <span class='ident'>in_macro</span>(<span class='ident'>cx</span>, <span class='ident'>ast_ty</span>.<span class='ident'>span</span>) {
            <span class='kw'>return</span>;
        }
        <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>ty</span>) <span class='op'>=</span> <span class='ident'>cx</span>.<span class='ident'>tcx</span>.<span class='ident'>ast_ty_to_ty_cache</span>.<span class='ident'>borrow</span>().<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='ident'>ast_ty</span>.<span class='ident'>id</span>) {
            <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>ty</span>::<span class='ident'>TyBox</span>(<span class='kw-2'>ref</span> <span class='ident'>inner</span>) <span class='op'>=</span> <span class='ident'>ty</span>.<span class='ident'>sty</span> {
                <span class='kw'>if</span> <span class='ident'>match_type</span>(<span class='ident'>cx</span>, <span class='ident'>inner</span>, <span class='kw-2'>&amp;</span><span class='ident'>VEC_PATH</span>) {
                    <span class='ident'>span_help_and_lint</span>(<span class='ident'>cx</span>,
                                       <span class='ident'>BOX_VEC</span>,
                                       <span class='ident'>ast_ty</span>.<span class='ident'>span</span>,
                                       <span class='string'>&quot;you seem to be trying to use `Box&lt;Vec&lt;T&gt;&gt;`. Consider using just `Vec&lt;T&gt;`&quot;</span>,
                                       <span class='string'>&quot;`Vec&lt;T&gt;` is already on the heap, `Box&lt;Vec&lt;T&gt;&gt;` makes an extra allocation.&quot;</span>);
                }
            } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>match_type</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>, <span class='kw-2'>&amp;</span><span class='ident'>LL_PATH</span>) {
                <span class='ident'>span_help_and_lint</span>(<span class='ident'>cx</span>,
                                   <span class='ident'>LINKEDLIST</span>,
                                   <span class='ident'>ast_ty</span>.<span class='ident'>span</span>,
                                   <span class='string'>&quot;I see you&#39;re using a LinkedList! Perhaps you meant some other data structure?&quot;</span>,
                                   <span class='string'>&quot;a VecDeque might work&quot;</span>);
            }
        }
    }
}

<span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_copy_implementations</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>LetPass</span>;

<span class='doccomment'>/// **What it does:** This lint checks for binding a unit value. It is `Warn` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** A unit value cannot usefully be used anywhere. So binding one is kind of pointless.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `let x = { 1; };`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>LET_UNIT_VALUE</span>, <span class='ident'>Warn</span>,
              <span class='string'>&quot;creating a let binding to a value of unit type, which usually can&#39;t be used afterwards&quot;</span>);

<span class='kw'>fn</span> <span class='ident'>check_let_unit</span>(<span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>decl</span>: <span class='kw-2'>&amp;</span><span class='ident'>Decl</span>) {
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>DeclLocal</span>(<span class='kw-2'>ref</span> <span class='ident'>local</span>) <span class='op'>=</span> <span class='ident'>decl</span>.<span class='ident'>node</span> {
        <span class='kw'>let</span> <span class='ident'>bindtype</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>cx</span>.<span class='ident'>tcx</span>.<span class='ident'>pat_ty</span>(<span class='kw-2'>&amp;</span><span class='ident'>local</span>.<span class='ident'>pat</span>).<span class='ident'>sty</span>;
        <span class='kw'>if</span> <span class='op'>*</span><span class='ident'>bindtype</span> <span class='op'>==</span> <span class='ident'>ty</span>::<span class='ident'>TyTuple</span>(<span class='macro'>vec</span><span class='macro'>!</span>[]) {
            <span class='kw'>if</span> <span class='ident'>in_external_macro</span>(<span class='ident'>cx</span>, <span class='ident'>decl</span>.<span class='ident'>span</span>) <span class='op'>||</span> <span class='ident'>in_macro</span>(<span class='ident'>cx</span>, <span class='ident'>local</span>.<span class='ident'>pat</span>.<span class='ident'>span</span>) {
                <span class='kw'>return</span>;
            }
            <span class='kw'>if</span> <span class='ident'>is_from_for_desugar</span>(<span class='ident'>decl</span>) {
                <span class='kw'>return</span>;
            }
            <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                      <span class='ident'>LET_UNIT_VALUE</span>,
                      <span class='ident'>decl</span>.<span class='ident'>span</span>,
                      <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;this let-binding has unit value. Consider omitting `let {} =`&quot;</span>,
                               <span class='ident'>snippet</span>(<span class='ident'>cx</span>, <span class='ident'>local</span>.<span class='ident'>pat</span>.<span class='ident'>span</span>, <span class='string'>&quot;..&quot;</span>)));
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>LintPass</span> <span class='kw'>for</span> <span class='ident'>LetPass</span> {
    <span class='kw'>fn</span> <span class='ident'>get_lints</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LintArray</span> {
        <span class='macro'>lint_array</span><span class='macro'>!</span>(<span class='ident'>LET_UNIT_VALUE</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>LateLintPass</span> <span class='kw'>for</span> <span class='ident'>LetPass</span> {
    <span class='kw'>fn</span> <span class='ident'>check_decl</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>decl</span>: <span class='kw-2'>&amp;</span><span class='ident'>Decl</span>) {
        <span class='ident'>check_let_unit</span>(<span class='ident'>cx</span>, <span class='ident'>decl</span>)
    }
}

<span class='doccomment'>/// **What it does:** This lint checks for comparisons to unit. It is `Warn` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** Unit is always equal to itself, and thus is just a clumsily written constant. Mostly this happens when someone accidentally adds semicolons at the end of the operands.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `if { foo(); } == { bar(); } { baz(); }` is equal to `{ foo(); bar(); baz(); }`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>UNIT_CMP</span>, <span class='ident'>Warn</span>,
              <span class='string'>&quot;comparing unit values (which is always `true` or `false`, respectively)&quot;</span>);

<span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_copy_implementations</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>UnitCmp</span>;

<span class='kw'>impl</span> <span class='ident'>LintPass</span> <span class='kw'>for</span> <span class='ident'>UnitCmp</span> {
    <span class='kw'>fn</span> <span class='ident'>get_lints</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LintArray</span> {
        <span class='macro'>lint_array</span><span class='macro'>!</span>(<span class='ident'>UNIT_CMP</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>LateLintPass</span> <span class='kw'>for</span> <span class='ident'>UnitCmp</span> {
    <span class='kw'>fn</span> <span class='ident'>check_expr</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>expr</span>: <span class='kw-2'>&amp;</span><span class='ident'>Expr</span>) {
        <span class='kw'>if</span> <span class='ident'>in_macro</span>(<span class='ident'>cx</span>, <span class='ident'>expr</span>.<span class='ident'>span</span>) {
            <span class='kw'>return</span>;
        }
        <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>ExprBinary</span>(<span class='kw-2'>ref</span> <span class='ident'>cmp</span>, <span class='kw-2'>ref</span> <span class='ident'>left</span>, _) <span class='op'>=</span> <span class='ident'>expr</span>.<span class='ident'>node</span> {
            <span class='kw'>let</span> <span class='ident'>op</span> <span class='op'>=</span> <span class='ident'>cmp</span>.<span class='ident'>node</span>;
            <span class='kw'>let</span> <span class='ident'>sty</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>cx</span>.<span class='ident'>tcx</span>.<span class='ident'>expr_ty</span>(<span class='ident'>left</span>).<span class='ident'>sty</span>;
            <span class='kw'>if</span> <span class='op'>*</span><span class='ident'>sty</span> <span class='op'>==</span> <span class='ident'>ty</span>::<span class='ident'>TyTuple</span>(<span class='macro'>vec</span><span class='macro'>!</span>[]) <span class='op'>&amp;&amp;</span> <span class='ident'>is_comparison_binop</span>(<span class='ident'>op</span>) {
                <span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>op</span> {
                    <span class='ident'>BiEq</span> <span class='op'>|</span> <span class='ident'>BiLe</span> <span class='op'>|</span> <span class='ident'>BiGe</span> <span class='op'>=&gt;</span> <span class='string'>&quot;true&quot;</span>,
                    _ <span class='op'>=&gt;</span> <span class='string'>&quot;false&quot;</span>,
                };
                <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                          <span class='ident'>UNIT_CMP</span>,
                          <span class='ident'>expr</span>.<span class='ident'>span</span>,
                          <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{}-comparison of unit values detected. This will always be {}&quot;</span>,
                                   <span class='ident'>binop_to_string</span>(<span class='ident'>op</span>),
                                   <span class='ident'>result</span>));
            }
        }
    }
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>CastPass</span>;

<span class='doccomment'>/// **What it does:** This lint checks for casts from any numerical to a float type where the receiving type cannot store all values from the original type without rounding errors. This possible rounding is to be expected, so this lint is `Allow` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// Basically, this warns on casting any integer with 32 or more bits to `f32` or any 64-bit integer to `f64`.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** It&#39;s not bad at all. But in some applications it can be helpful to know where precision loss can take place. This lint can help find those places in the code.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `let x = u64::MAX; x as f64`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>CAST_PRECISION_LOSS</span>, <span class='ident'>Allow</span>,
              <span class='string'>&quot;casts that cause loss of precision, e.g `x as f32` where `x: u64`&quot;</span>);
<span class='doccomment'>/// **What it does:** This lint checks for casts from a signed to an unsigned numerical type. In this case, negative values wrap around to large positive values, which can be quite surprising in practice. However, as the cast works as defined, this lint is `Allow` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** Possibly surprising results. You can activate this lint as a one-time check to see where numerical wrapping can arise.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `let y : i8 = -1; y as u64` will return 18446744073709551615</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>CAST_SIGN_LOSS</span>, <span class='ident'>Allow</span>,
              <span class='string'>&quot;casts from signed types to unsigned types, e.g `x as u32` where `x: i32`&quot;</span>);
<span class='doccomment'>/// **What it does:** This lint checks for on casts between numerical types that may truncate large values. This is expected behavior, so the cast is `Allow` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** In some problem domains, it is good practice to avoid truncation. This lint can be activated to help assess where additional checks could be beneficial.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `fn as_u8(x: u64) -&gt; u8 { x as u8 }`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>CAST_POSSIBLE_TRUNCATION</span>, <span class='ident'>Allow</span>,
              <span class='string'>&quot;casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`&quot;</span>);
<span class='doccomment'>/// **What it does:** This lint checks for casts from an unsigned type to a signed type of the same size. Performing such a cast is a &#39;no-op&#39; for the compiler, i.e. nothing is changed at the bit level, and the binary representation of the value is reinterpreted. This can cause wrapping if the value is too big for the target signed type. However, the cast works as defined, so this lint is `Allow` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** While such a cast is not bad in itself, the results can be surprising when this is not the intended behavior, as demonstrated by the example below.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `u32::MAX as i32` will yield a value of `-1`.</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>CAST_POSSIBLE_WRAP</span>, <span class='ident'>Allow</span>,
              <span class='string'>&quot;casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x &gt; i32::MAX`&quot;</span>);

<span class='doccomment'>/// Returns the size in bits of an integral type.</span>
<span class='doccomment'>/// Will return 0 if the type is not an int or uint variant</span>
<span class='kw'>fn</span> <span class='ident'>int_ty_to_nbits</span>(<span class='ident'>typ</span>: <span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyS</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>typ</span>.<span class='ident'>sty</span> {
        <span class='ident'>ty</span>::<span class='ident'>TyInt</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='number'>4</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>i</span> <span class='kw'>as</span> <span class='ident'>usize</span>),
        <span class='ident'>ty</span>::<span class='ident'>TyUint</span>(<span class='ident'>u</span>) <span class='op'>=&gt;</span> <span class='number'>4</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>u</span> <span class='kw'>as</span> <span class='ident'>usize</span>),
        _ <span class='op'>=&gt;</span> <span class='number'>0</span>,
    };
    <span class='comment'>// n == 4 is the usize/isize case</span>
    <span class='kw'>if</span> <span class='ident'>n</span> <span class='op'>==</span> <span class='number'>4</span> {
        ::<span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span>() <span class='op'>*</span> <span class='number'>8</span>
    } <span class='kw'>else</span> {
        <span class='ident'>n</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>is_isize_or_usize</span>(<span class='ident'>typ</span>: <span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyS</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='kw'>match</span> <span class='ident'>typ</span>.<span class='ident'>sty</span> {
        <span class='ident'>ty</span>::<span class='ident'>TyInt</span>(<span class='ident'>TyIs</span>) <span class='op'>|</span> <span class='ident'>ty</span>::<span class='ident'>TyUint</span>(<span class='ident'>TyUs</span>) <span class='op'>=&gt;</span> <span class='boolval'>true</span>,
        _ <span class='op'>=&gt;</span> <span class='boolval'>false</span>,
    }
}

<span class='kw'>fn</span> <span class='ident'>span_precision_loss_lint</span>(<span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>expr</span>: <span class='kw-2'>&amp;</span><span class='ident'>Expr</span>, <span class='ident'>cast_from</span>: <span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyS</span>, <span class='ident'>cast_to_f64</span>: <span class='ident'>bool</span>) {
    <span class='kw'>let</span> <span class='ident'>mantissa_nbits</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>cast_to_f64</span> {
        <span class='number'>52</span>
    } <span class='kw'>else</span> {
        <span class='number'>23</span>
    };
    <span class='kw'>let</span> <span class='ident'>arch_dependent</span> <span class='op'>=</span> <span class='ident'>is_isize_or_usize</span>(<span class='ident'>cast_from</span>) <span class='op'>&amp;&amp;</span> <span class='ident'>cast_to_f64</span>;
    <span class='kw'>let</span> <span class='ident'>arch_dependent_str</span> <span class='op'>=</span> <span class='string'>&quot;on targets with 64-bit wide pointers &quot;</span>;
    <span class='kw'>let</span> <span class='ident'>from_nbits_str</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>arch_dependent</span> {
        <span class='string'>&quot;64&quot;</span>.<span class='ident'>to_owned</span>()
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>is_isize_or_usize</span>(<span class='ident'>cast_from</span>) {
        <span class='string'>&quot;32 or 64&quot;</span>.<span class='ident'>to_owned</span>()
    } <span class='kw'>else</span> {
        <span class='ident'>int_ty_to_nbits</span>(<span class='ident'>cast_from</span>).<span class='ident'>to_string</span>()
    };
    <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
              <span class='ident'>CAST_PRECISION_LOSS</span>,
              <span class='ident'>expr</span>.<span class='ident'>span</span>,
              <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}&#39;s mantissa \
                        is only {4} bits wide)&quot;</span>,
                       <span class='ident'>cast_from</span>,
                       <span class='kw'>if</span> <span class='ident'>cast_to_f64</span> {
                           <span class='string'>&quot;f64&quot;</span>
                       } <span class='kw'>else</span> {
                           <span class='string'>&quot;f32&quot;</span>
                       },
                       <span class='kw'>if</span> <span class='ident'>arch_dependent</span> {
                           <span class='ident'>arch_dependent_str</span>
                       } <span class='kw'>else</span> {
                           <span class='string'>&quot;&quot;</span>
                       },
                       <span class='ident'>from_nbits_str</span>,
                       <span class='ident'>mantissa_nbits</span>));
}

<span class='kw'>enum</span> <span class='ident'>ArchSuffix</span> {
    <span class='ident'>_32</span>,
    <span class='ident'>_64</span>,
    <span class='prelude-val'>None</span>,
}

<span class='kw'>fn</span> <span class='ident'>check_truncation_and_wrapping</span>(<span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>expr</span>: <span class='kw-2'>&amp;</span><span class='ident'>Expr</span>, <span class='ident'>cast_from</span>: <span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyS</span>, <span class='ident'>cast_to</span>: <span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyS</span>) {
    <span class='kw'>let</span> <span class='ident'>arch_64_suffix</span> <span class='op'>=</span> <span class='string'>&quot; on targets with 64-bit wide pointers&quot;</span>;
    <span class='kw'>let</span> <span class='ident'>arch_32_suffix</span> <span class='op'>=</span> <span class='string'>&quot; on targets with 32-bit wide pointers&quot;</span>;
    <span class='kw'>let</span> <span class='ident'>cast_unsigned_to_signed</span> <span class='op'>=</span> <span class='op'>!</span><span class='ident'>cast_from</span>.<span class='ident'>is_signed</span>() <span class='op'>&amp;&amp;</span> <span class='ident'>cast_to</span>.<span class='ident'>is_signed</span>();
    <span class='kw'>let</span> (<span class='ident'>from_nbits</span>, <span class='ident'>to_nbits</span>) <span class='op'>=</span> (<span class='ident'>int_ty_to_nbits</span>(<span class='ident'>cast_from</span>), <span class='ident'>int_ty_to_nbits</span>(<span class='ident'>cast_to</span>));
    <span class='kw'>let</span> (<span class='ident'>span_truncation</span>, <span class='ident'>suffix_truncation</span>, <span class='ident'>span_wrap</span>, <span class='ident'>suffix_wrap</span>) <span class='op'>=</span> <span class='kw'>match</span> (<span class='ident'>is_isize_or_usize</span>(<span class='ident'>cast_from</span>),
                                                                              <span class='ident'>is_isize_or_usize</span>(<span class='ident'>cast_to</span>)) {
        (<span class='boolval'>true</span>, <span class='boolval'>true</span>) <span class='op'>|</span> (<span class='boolval'>false</span>, <span class='boolval'>false</span>) <span class='op'>=&gt;</span> {
            (<span class='ident'>to_nbits</span> <span class='op'>&lt;</span> <span class='ident'>from_nbits</span>,
             <span class='ident'>ArchSuffix</span>::<span class='prelude-val'>None</span>,
             <span class='ident'>to_nbits</span> <span class='op'>==</span> <span class='ident'>from_nbits</span> <span class='op'>&amp;&amp;</span> <span class='ident'>cast_unsigned_to_signed</span>,
             <span class='ident'>ArchSuffix</span>::<span class='prelude-val'>None</span>)
        }
        (<span class='boolval'>true</span>, <span class='boolval'>false</span>) <span class='op'>=&gt;</span> {
            (<span class='ident'>to_nbits</span> <span class='op'>&lt;=</span> <span class='number'>32</span>,
             <span class='kw'>if</span> <span class='ident'>to_nbits</span> <span class='op'>==</span> <span class='number'>32</span> {
                <span class='ident'>ArchSuffix</span>::<span class='ident'>_64</span>
            } <span class='kw'>else</span> {
                <span class='ident'>ArchSuffix</span>::<span class='prelude-val'>None</span>
            },
             <span class='ident'>to_nbits</span> <span class='op'>&lt;=</span> <span class='number'>32</span> <span class='op'>&amp;&amp;</span> <span class='ident'>cast_unsigned_to_signed</span>,
             <span class='ident'>ArchSuffix</span>::<span class='ident'>_32</span>)
        }
        (<span class='boolval'>false</span>, <span class='boolval'>true</span>) <span class='op'>=&gt;</span> {
            (<span class='ident'>from_nbits</span> <span class='op'>==</span> <span class='number'>64</span>,
             <span class='ident'>ArchSuffix</span>::<span class='ident'>_32</span>,
             <span class='ident'>cast_unsigned_to_signed</span>,
             <span class='kw'>if</span> <span class='ident'>from_nbits</span> <span class='op'>==</span> <span class='number'>64</span> {
                <span class='ident'>ArchSuffix</span>::<span class='ident'>_64</span>
            } <span class='kw'>else</span> {
                <span class='ident'>ArchSuffix</span>::<span class='ident'>_32</span>
            })
        }
    };
    <span class='kw'>if</span> <span class='ident'>span_truncation</span> {
        <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                  <span class='ident'>CAST_POSSIBLE_TRUNCATION</span>,
                  <span class='ident'>expr</span>.<span class='ident'>span</span>,
                  <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;casting {} to {} may truncate the value{}&quot;</span>,
                           <span class='ident'>cast_from</span>,
                           <span class='ident'>cast_to</span>,
                           <span class='kw'>match</span> <span class='ident'>suffix_truncation</span> {
                               <span class='ident'>ArchSuffix</span>::<span class='ident'>_32</span> <span class='op'>=&gt;</span> <span class='ident'>arch_32_suffix</span>,
                               <span class='ident'>ArchSuffix</span>::<span class='ident'>_64</span> <span class='op'>=&gt;</span> <span class='ident'>arch_64_suffix</span>,
                               <span class='ident'>ArchSuffix</span>::<span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='string'>&quot;&quot;</span>,
                           }));
    }
    <span class='kw'>if</span> <span class='ident'>span_wrap</span> {
        <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                  <span class='ident'>CAST_POSSIBLE_WRAP</span>,
                  <span class='ident'>expr</span>.<span class='ident'>span</span>,
                  <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;casting {} to {} may wrap around the value{}&quot;</span>,
                           <span class='ident'>cast_from</span>,
                           <span class='ident'>cast_to</span>,
                           <span class='kw'>match</span> <span class='ident'>suffix_wrap</span> {
                               <span class='ident'>ArchSuffix</span>::<span class='ident'>_32</span> <span class='op'>=&gt;</span> <span class='ident'>arch_32_suffix</span>,
                               <span class='ident'>ArchSuffix</span>::<span class='ident'>_64</span> <span class='op'>=&gt;</span> <span class='ident'>arch_64_suffix</span>,
                               <span class='ident'>ArchSuffix</span>::<span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='string'>&quot;&quot;</span>,
                           }));
    }
}

<span class='kw'>impl</span> <span class='ident'>LintPass</span> <span class='kw'>for</span> <span class='ident'>CastPass</span> {
    <span class='kw'>fn</span> <span class='ident'>get_lints</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LintArray</span> {
        <span class='macro'>lint_array</span><span class='macro'>!</span>(<span class='ident'>CAST_PRECISION_LOSS</span>,
                    <span class='ident'>CAST_SIGN_LOSS</span>,
                    <span class='ident'>CAST_POSSIBLE_TRUNCATION</span>,
                    <span class='ident'>CAST_POSSIBLE_WRAP</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>LateLintPass</span> <span class='kw'>for</span> <span class='ident'>CastPass</span> {
    <span class='kw'>fn</span> <span class='ident'>check_expr</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>expr</span>: <span class='kw-2'>&amp;</span><span class='ident'>Expr</span>) {
        <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>ExprCast</span>(<span class='kw-2'>ref</span> <span class='ident'>ex</span>, _) <span class='op'>=</span> <span class='ident'>expr</span>.<span class='ident'>node</span> {
            <span class='kw'>let</span> (<span class='ident'>cast_from</span>, <span class='ident'>cast_to</span>) <span class='op'>=</span> (<span class='ident'>cx</span>.<span class='ident'>tcx</span>.<span class='ident'>expr_ty</span>(<span class='ident'>ex</span>), <span class='ident'>cx</span>.<span class='ident'>tcx</span>.<span class='ident'>expr_ty</span>(<span class='ident'>expr</span>));
            <span class='kw'>if</span> <span class='ident'>cast_from</span>.<span class='ident'>is_numeric</span>() <span class='op'>&amp;&amp;</span> <span class='ident'>cast_to</span>.<span class='ident'>is_numeric</span>() <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='ident'>in_external_macro</span>(<span class='ident'>cx</span>, <span class='ident'>expr</span>.<span class='ident'>span</span>) {
                <span class='kw'>match</span> (<span class='ident'>cast_from</span>.<span class='ident'>is_integral</span>(), <span class='ident'>cast_to</span>.<span class='ident'>is_integral</span>()) {
                    (<span class='boolval'>true</span>, <span class='boolval'>false</span>) <span class='op'>=&gt;</span> {
                        <span class='kw'>let</span> <span class='ident'>from_nbits</span> <span class='op'>=</span> <span class='ident'>int_ty_to_nbits</span>(<span class='ident'>cast_from</span>);
                        <span class='kw'>let</span> <span class='ident'>to_nbits</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>ty</span>::<span class='ident'>TyFloat</span>(<span class='ident'>TyF32</span>) <span class='op'>=</span> <span class='ident'>cast_to</span>.<span class='ident'>sty</span> {
                            <span class='number'>32</span>
                        } <span class='kw'>else</span> {
                            <span class='number'>64</span>
                        };
                        <span class='kw'>if</span> <span class='ident'>is_isize_or_usize</span>(<span class='ident'>cast_from</span>) <span class='op'>||</span> <span class='ident'>from_nbits</span> <span class='op'>&gt;=</span> <span class='ident'>to_nbits</span> {
                            <span class='ident'>span_precision_loss_lint</span>(<span class='ident'>cx</span>, <span class='ident'>expr</span>, <span class='ident'>cast_from</span>, <span class='ident'>to_nbits</span> <span class='op'>==</span> <span class='number'>64</span>);
                        }
                    }
                    (<span class='boolval'>false</span>, <span class='boolval'>true</span>) <span class='op'>=&gt;</span> {
                        <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                                  <span class='ident'>CAST_POSSIBLE_TRUNCATION</span>,
                                  <span class='ident'>expr</span>.<span class='ident'>span</span>,
                                  <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;casting {} to {} may truncate the value&quot;</span>, <span class='ident'>cast_from</span>, <span class='ident'>cast_to</span>));
                        <span class='kw'>if</span> <span class='op'>!</span><span class='ident'>cast_to</span>.<span class='ident'>is_signed</span>() {
                            <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                                      <span class='ident'>CAST_SIGN_LOSS</span>,
                                      <span class='ident'>expr</span>.<span class='ident'>span</span>,
                                      <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;casting {} to {} may lose the sign of the value&quot;</span>, <span class='ident'>cast_from</span>, <span class='ident'>cast_to</span>));
                        }
                    }
                    (<span class='boolval'>true</span>, <span class='boolval'>true</span>) <span class='op'>=&gt;</span> {
                        <span class='kw'>if</span> <span class='ident'>cast_from</span>.<span class='ident'>is_signed</span>() <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='ident'>cast_to</span>.<span class='ident'>is_signed</span>() {
                            <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                                      <span class='ident'>CAST_SIGN_LOSS</span>,
                                      <span class='ident'>expr</span>.<span class='ident'>span</span>,
                                      <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;casting {} to {} may lose the sign of the value&quot;</span>, <span class='ident'>cast_from</span>, <span class='ident'>cast_to</span>));
                        }
                        <span class='ident'>check_truncation_and_wrapping</span>(<span class='ident'>cx</span>, <span class='ident'>expr</span>, <span class='ident'>cast_from</span>, <span class='ident'>cast_to</span>);
                    }
                    (<span class='boolval'>false</span>, <span class='boolval'>false</span>) <span class='op'>=&gt;</span> {
                        <span class='kw'>if</span> <span class='kw'>let</span> (<span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyFloat</span>(<span class='ident'>TyF64</span>), <span class='kw-2'>&amp;</span><span class='ident'>ty</span>::<span class='ident'>TyFloat</span>(<span class='ident'>TyF32</span>)) <span class='op'>=</span> (<span class='kw-2'>&amp;</span><span class='ident'>cast_from</span>.<span class='ident'>sty</span>, <span class='kw-2'>&amp;</span><span class='ident'>cast_to</span>.<span class='ident'>sty</span>) {
                            <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                                      <span class='ident'>CAST_POSSIBLE_TRUNCATION</span>,
                                      <span class='ident'>expr</span>.<span class='ident'>span</span>,
                                      <span class='string'>&quot;casting f64 to f32 may truncate the value&quot;</span>);
                        }
                    }
                }
            }
        }
    }
}

<span class='doccomment'>/// **What it does:** This lint checks for types used in structs, parameters and `let` declarations above a certain complexity threshold. It is `Warn` by default.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Why is this bad?** Too complex types make the code less readable. Consider using a `type` definition to simplify them.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Known problems:** None</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// **Example:** `struct Foo { inner: Rc&lt;Vec&lt;Vec&lt;Box&lt;(u32, u32, u32, u32)&gt;&gt;&gt;&gt; }`</span>
<span class='macro'>declare_lint</span><span class='macro'>!</span>(<span class='kw'>pub</span> <span class='ident'>TYPE_COMPLEXITY</span>, <span class='ident'>Warn</span>,
              <span class='string'>&quot;usage of very complex types; recommends factoring out parts into `type` definitions&quot;</span>);

<span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>missing_copy_implementations</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>TypeComplexityPass</span>;

<span class='kw'>impl</span> <span class='ident'>LintPass</span> <span class='kw'>for</span> <span class='ident'>TypeComplexityPass</span> {
    <span class='kw'>fn</span> <span class='ident'>get_lints</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LintArray</span> {
        <span class='macro'>lint_array</span><span class='macro'>!</span>(<span class='ident'>TYPE_COMPLEXITY</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>LateLintPass</span> <span class='kw'>for</span> <span class='ident'>TypeComplexityPass</span> {
    <span class='kw'>fn</span> <span class='ident'>check_fn</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, _: <span class='ident'>FnKind</span>, <span class='ident'>decl</span>: <span class='kw-2'>&amp;</span><span class='ident'>FnDecl</span>, _: <span class='kw-2'>&amp;</span><span class='ident'>Block</span>, _: <span class='ident'>Span</span>, _: <span class='ident'>NodeId</span>) {
        <span class='ident'>check_fndecl</span>(<span class='ident'>cx</span>, <span class='ident'>decl</span>);
    }

    <span class='kw'>fn</span> <span class='ident'>check_struct_field</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>field</span>: <span class='kw-2'>&amp;</span><span class='ident'>StructField</span>) {
        <span class='comment'>// enum variants are also struct fields now</span>
        <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='kw-2'>&amp;</span><span class='ident'>field</span>.<span class='ident'>node</span>.<span class='ident'>ty</span>);
    }

    <span class='kw'>fn</span> <span class='ident'>check_item</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>item</span>: <span class='kw-2'>&amp;</span><span class='ident'>Item</span>) {
        <span class='kw'>match</span> <span class='ident'>item</span>.<span class='ident'>node</span> {
            <span class='ident'>ItemStatic</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>, _, _) <span class='op'>|</span>
            <span class='ident'>ItemConst</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>, _) <span class='op'>=&gt;</span> <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>),
            <span class='comment'>// functions, enums, structs, impls and traits are covered</span>
            _ <span class='op'>=&gt;</span> (),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>check_trait_item</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>item</span>: <span class='kw-2'>&amp;</span><span class='ident'>TraitItem</span>) {
        <span class='kw'>match</span> <span class='ident'>item</span>.<span class='ident'>node</span> {
            <span class='ident'>ConstTraitItem</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>, _) <span class='op'>|</span>
            <span class='ident'>TypeTraitItem</span>(_, <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>)) <span class='op'>=&gt;</span> <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>),
            <span class='ident'>MethodTraitItem</span>(<span class='ident'>MethodSig</span> { <span class='kw-2'>ref</span> <span class='ident'>decl</span>, .. }, <span class='prelude-val'>None</span>) <span class='op'>=&gt;</span> <span class='ident'>check_fndecl</span>(<span class='ident'>cx</span>, <span class='ident'>decl</span>),
            <span class='comment'>// methods with default impl are covered by check_fn</span>
            _ <span class='op'>=&gt;</span> (),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>check_impl_item</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>item</span>: <span class='kw-2'>&amp;</span><span class='ident'>ImplItem</span>) {
        <span class='kw'>match</span> <span class='ident'>item</span>.<span class='ident'>node</span> {
            <span class='ident'>ImplItemKind</span>::<span class='ident'>Const</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>, _) <span class='op'>|</span>
            <span class='ident'>ImplItemKind</span>::<span class='ident'>Type</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>) <span class='op'>=&gt;</span> <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>),
            <span class='comment'>// methods are covered by check_fn</span>
            _ <span class='op'>=&gt;</span> (),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>check_local</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>local</span>: <span class='kw-2'>&amp;</span><span class='ident'>Local</span>) {
        <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>) <span class='op'>=</span> <span class='ident'>local</span>.<span class='ident'>ty</span> {
            <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>);
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>check_fndecl</span>(<span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>decl</span>: <span class='kw-2'>&amp;</span><span class='ident'>FnDecl</span>) {
    <span class='kw'>for</span> <span class='ident'>arg</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>decl</span>.<span class='ident'>inputs</span> {
        <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='kw-2'>&amp;</span><span class='ident'>arg</span>.<span class='ident'>ty</span>);
    }
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>Return</span>(<span class='kw-2'>ref</span> <span class='ident'>ty</span>) <span class='op'>=</span> <span class='ident'>decl</span>.<span class='ident'>output</span> {
        <span class='ident'>check_type</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>check_type</span>(<span class='ident'>cx</span>: <span class='kw-2'>&amp;</span><span class='ident'>LateContext</span>, <span class='ident'>ty</span>: <span class='kw-2'>&amp;</span><span class='ident'>Ty</span>) {
    <span class='kw'>if</span> <span class='ident'>in_macro</span>(<span class='ident'>cx</span>, <span class='ident'>ty</span>.<span class='ident'>span</span>) {
        <span class='kw'>return</span>;
    }
    <span class='kw'>let</span> <span class='ident'>score</span> <span class='op'>=</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>visitor</span> <span class='op'>=</span> <span class='ident'>TypeComplexityVisitor</span> {
            <span class='ident'>score</span>: <span class='number'>0</span>,
            <span class='ident'>nest</span>: <span class='number'>1</span>,
        };
        <span class='ident'>visitor</span>.<span class='ident'>visit_ty</span>(<span class='ident'>ty</span>);
        <span class='ident'>visitor</span>.<span class='ident'>score</span>
    };
    <span class='comment'>// println!(&quot;{:?} --&gt; {}&quot;, ty, score);</span>
    <span class='kw'>if</span> <span class='ident'>score</span> <span class='op'>&gt;</span> <span class='number'>250</span> {
        <span class='ident'>span_lint</span>(<span class='ident'>cx</span>,
                  <span class='ident'>TYPE_COMPLEXITY</span>,
                  <span class='ident'>ty</span>.<span class='ident'>span</span>,
                  <span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;very complex type used. Consider factoring parts into `type` definitions&quot;</span>));
    }
}

<span class='doccomment'>/// Walks a type and assigns a complexity score to it.</span>
<span class='kw'>struct</span> <span class='ident'>TypeComplexityVisitor</span> {
    <span class='doccomment'>/// total complexity score of the type</span>
    <span class='ident'>score</span>: <span class='ident'>u32</span>,
    <span class='doccomment'>/// current nesting level</span>
    <span class='ident'>nest</span>: <span class='ident'>u32</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;v</span><span class='op'>&gt;</span> <span class='ident'>Visitor</span><span class='op'>&lt;</span><span class='lifetime'>&#39;v</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>TypeComplexityVisitor</span> {
    <span class='kw'>fn</span> <span class='ident'>visit_ty</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>ty</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;v</span> <span class='ident'>Ty</span>) {
        <span class='kw'>let</span> (<span class='ident'>add_score</span>, <span class='ident'>sub_nest</span>) <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>ty</span>.<span class='ident'>node</span> {
            <span class='comment'>// _, &amp;x and *x have only small overhead; don&#39;t mess with nesting level</span>
            <span class='ident'>TyInfer</span> <span class='op'>|</span>
            <span class='ident'>TyPtr</span>(..) <span class='op'>|</span>
            <span class='ident'>TyRptr</span>(..) <span class='op'>=&gt;</span> (<span class='number'>1</span>, <span class='number'>0</span>),

            <span class='comment'>// the &quot;normal&quot; components of a type: named types, arrays/tuples</span>
            <span class='ident'>TyPath</span>(..) <span class='op'>|</span>
            <span class='ident'>TyVec</span>(..) <span class='op'>|</span>
            <span class='ident'>TyTup</span>(..) <span class='op'>|</span>
            <span class='ident'>TyFixedLengthVec</span>(..) <span class='op'>=&gt;</span> (<span class='number'>10</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>nest</span>, <span class='number'>1</span>),

            <span class='comment'>// &quot;Sum&quot; of trait bounds</span>
            <span class='ident'>TyObjectSum</span>(..) <span class='op'>=&gt;</span> (<span class='number'>20</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>nest</span>, <span class='number'>0</span>),

            <span class='comment'>// function types and &quot;for&lt;...&gt;&quot; bring a lot of overhead</span>
            <span class='ident'>TyBareFn</span>(..) <span class='op'>|</span>
            <span class='ident'>TyPolyTraitRef</span>(..) <span class='op'>=&gt;</span> (<span class='number'>50</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>nest</span>, <span class='number'>1</span>),

            _ <span class='op'>=&gt;</span> (<span class='number'>0</span>, <span class='number'>0</span>),
        };
        <span class='self'>self</span>.<span class='ident'>score</span> <span class='op'>+=</span> <span class='ident'>add_score</span>;
        <span class='self'>self</span>.<span class='ident'>nest</span> <span class='op'>+=</span> <span class='ident'>sub_nest</span>;
        <span class='ident'>walk_ty</span>(<span class='self'>self</span>, <span class='ident'>ty</span>);
        <span class='self'>self</span>.<span class='ident'>nest</span> <span class='op'>-=</span> <span class='ident'>sub_nest</span>;
    }
}
</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "clippy";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>