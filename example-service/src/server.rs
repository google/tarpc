// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

#![feature(arbitrary_self_types, async_await)]

use clap::{App, Arg};
use futures::{
    compat::Executor01CompatExt,
    future::{self, Ready},
    prelude::*,
};
use std::{io, net::SocketAddr};
use tarpc::{
    context,
    server::{self, Channel, Handler},
};

// This is the type that implements the generated Service trait. It is the business logic
// and is used to start the server.
#[derive(Clone)]
struct HelloServer(SocketAddr);

impl service::Service for HelloServer {
    // Each defined rpc generates two items in the trait, a fn that serves the RPC, and
    // an associated type representing the future output by the fn.

    type HelloFut = Ready<String>;

    fn hello(self, _: context::Context, name: String) -> Self::HelloFut {
        future::ready(format!(
            "Hello, {}! You are connected from {:?}.",
            name, self.0
        ))
    }
}

async fn run(server_addr: SocketAddr) -> io::Result<()> {
    // bincode_transport is provided by the associated crate bincode-transport. It makes it easy
    // to start up a serde-powered bincode serialization strategy over TCP.
    bincode_transport::listen(&server_addr)?
        .map_ok(server::BaseChannel::with_defaults)
        // Limit connections to 10 total, 1 per IP.
        .limit_connections(
            {
                let mut config = server::filter::Config::default();
                config.max_connections_per_key = 1;
                config.max_connections = 10;
                config
            },
            |t| t.get_ref().peer_addr().unwrap().ip(),
        )
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .map_ok(|channel| {
            let peer_addr = channel.get_ref().get_ref().peer_addr().unwrap();
            let handler = channel.respond_with(service::serve(HelloServer(peer_addr)));
            tokio::spawn(handler.unit_error().boxed().compat());
        })
        .for_each(|_| futures::future::ready(()))
        .await;

    Ok(())
}

fn main() {
    env_logger::init();

    let flags = App::new("Hello Server")
        .version("0.1")
        .author("Tim <tikue@google.com>")
        .about("Say hello!")
        .arg(
            Arg::with_name("port")
                .short("p")
                .long("port")
                .value_name("NUMBER")
                .help("Sets the port number to listen on")
                .required(true)
                .takes_value(true),
        )
        .get_matches();

    let port = flags.value_of("port").unwrap();
    let port = port
        .parse()
        .unwrap_or_else(|e| panic!(r#"--port value "{}" invalid: {}"#, port, e));

    tarpc::init(tokio::executor::DefaultExecutor::current().compat());

    tokio::run(
        run(([0, 0, 0, 0], port).into())
            .map_err(|e| eprintln!("Oh no: {}", e))
            .boxed()
            .compat(),
    );
}
